# ArrayMaps

传统的hashmap为了防止冲突，直接新建一个大的内存空间，也就是说如果数量特别少的话，是很浪费内存的。
Android提供了ArrayMap，这个相比就特别节省内存空间，但是它的缺点是增删改查的速度比较慢。

适用场景：
- 存储的object数目不超过1000，访问特别多，但是增删比较少。
- 当我们有映射的容器，比如映射的映射，子映射倾向于低数量的项目，经常需要对他们迭代。

# 自动装箱
将基本数据类型自动转换成对应的对象版本。可以使用泛型集合，这个就是自动装箱起到的作用。每次的装箱操作都会产生一个新的对象。
像Integer.valueof尤其是耗性能的。

- SparseArray

类似于ArrayMap，使用两种紧密包装的数组，而不是一个大的哈希散列，从而减少内存覆盖区域。不同点就是SparseArray内的key都是基本数据类型，而不是通用的，这就避免了自动装箱。
应用场景和ArrayMap是一样的。


# 枚举

每当一个应用加载的时候，Android会为应用预留一定的系统内存，为了让应用运行的多有的dex代码都载入那个子空间，这个空间最后会和剩余的堆共享，但是这个不和运行的配置竞争内存，但是为系统的运行增加了压力，当系统运行内存不足时，则会释放应用的内存。
综上，当使用枚举，而不是整型的时候，会增加dex的大小，一个枚举值，差不多是一个整型占用内存的13倍，会增加dex文件，消耗堆空间。
此外，每声明一个枚举值，将会额外消耗20字节，还需要数组对象存储枚举值，又是将近12-16字节，所以每个枚举值的声明都是需要额外的消耗的。

- 解决之道：

使用注解解决@IntDef(value = {TYPE1, TYPE2, TYPE3})

# 后台应用内存回收

onLowMemory，onTrimMemory

# 避免因为view造成的内存泄露

- 不要再异步回调里调用view；
- 不要在静态对象中引用view，因为静态对象存在于应用运行的整个期间。
- 不要将view存放在键值对的集合中。映射的时候会将view当做强引用。


